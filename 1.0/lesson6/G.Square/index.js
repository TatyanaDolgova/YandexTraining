// Городская площадь имеет размер n× m и покрыта квадратной плиткой размером 1× 1. При плановой замене плитки
// выяснилось, что новой плитки недостаточно для покрытия всей площади, поэтому было решено покрыть плиткой только
// дорожку по краю площади, а в центре площади разбить прямоугольную клумбу (см. рисунок к примеру). При этом 
// дорожка должна иметь одинаковую ширину по всем сторонам площади. Определите максимальную ширину дорожки, 
// которую можно выложить из имеющихся плиток.

// Формат ввода
// Первая и вторая строки входных данных содержат по одному числу n и m (3≤ n ≤ 2× 109, 3≤ m ≤ 2× 109) — размеры 
// площади.

// Третья строка содержит количество имеющихся плиток t, 1≤ t< nm.

// Обратите внимание, что значение t может быть больше, чем возможное значение 32-битной целочисленной переменной, 
// поэтому необходимо использовать 64-битные числа (тип int64 в языке Pascal, тип long long в C и C++, тип long в 
//   Java и C#).

// Формат вывода
// Программа должна вывести единственное число — максимальную ширину дорожки, которую можно выложить из 
// имеющихся плиток.

// Пример
// Ввод	
// 6
// 7
// 38
// Вывод
// 2
const fs = require('fs');

const data = fs.readFileSync('input.txt', { encoding: 'utf8' });
const [n, m, t] = data.toString().trim().split('\n').map(BigInt);

const binarySearch = (n, m, t) => {
  let max = 0n;

  if (n > m) {
    max = n;
  } else {
    max = m;
  }

  let right = (max + 1n) / 2n;
  let left = -1n;
  let mid;

  while (right - left > 1n) {
    mid = (right + left) / 2n;

    const count = (n * mid * 2n) + (m - mid * 2n) * mid * 2n;
    if (count <= t) {
      left = mid;
    } else {
      right = mid;
    }
  }

  return left;
}

let result = binarySearch(n, m, t);
fs.writeFileSync('output.txt', result.toString());